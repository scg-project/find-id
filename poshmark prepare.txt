76
72
4
354
198
70
69
101
204
832
863
322
127
https://github.com/frankxwang/empathy-hackathon-backend
left shift 
right shift
Calculator




# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

Square Root problems


from collections import OrderedDict
class LRUCache(OrderedDict):

    def __init__(self, capacity: int):
        self.capacity=capacity

    def get(self, key: int) -> int:
        if key  not in self: return -1
        self.move_to_end(key)
        return self[key]

    def put(self, key: int, value: int) -> None:
        if key in self:
            self.move_to_end(key)
        self[key]=value
        if len(self)>self.capacity:
            self.popitem(last=False)


# Your LRUCache object will be instantiated and called as such:
# obj = LRUCache(capacity)
# param_1 = obj.get(key)
# obj.put(key,value)



There are three boxes, one contains only apples, one contains only oranges, and one contains both apples and oranges. The boxes have been incorrectly labeled such that no label identifies the actual contents of the box it labels. Opening just one box, and without looking in the box, you take out one piece of fruit. By looking at the fruit, how can you immediately label all of the boxes correctly?
Just share some thoughts with boxes question.
To solve that problem, we can just grab one fruit from the box with both apples and oranges label.
If the fruit is orange, then the box must be the box of only oranges as there is no correct label on each boxes initially.
For the rest 2 boxes, the one with label apple only must be the both apples and oranges the original apple label is wrong so there is only one possibility and that's the both apples and oranges.
The last one is the apple box.



comparator in java:
Arrays.sort(arr, new Comparator<int[]>() { 
            
          @Override              
          // Compare values according to columns 
          public int compare(final int[] entry1,  
                             final int[] entry2) { 
  
            // To sort in descending order revert  
            // the '>' Operator 
            if (entry1[0] > entry2[0]) 
                return 1; 
            else
                return -1; 
          } 
        });  //
        

    // Min heap
    PriorityQueue<Integer> allocator =
        new PriorityQueue<Integer>(
            intervals.length,
            new Comparator<Integer>() {
              public int compare(Integer a, Integer b) {
                return a - b;
              }
            });

    // Sort the intervals by start time
    Arrays.sort(
        intervals,
        new Comparator<int[]>() {
          public int compare(final int[] a, final int[] b) {
            return a[0] - b[0];
          }
        });




To make subarray:
nums is the main array here
int[] temp=Arrays.copyOfRange(nums, 0, 1 + 1);

Find Middle:
int midIndex=left + ((right - left) >> 1);


	
Work on team hirarchy navid





/*
 * Click `Run` to execute the snippet below!
 */

import java.io.*;
import java.util.*;

/*
 * To execute Java, please define "static void main" on a class
 * named Solution.
 *
 * If you need more classes, simply define them inline.
 */
/*
Given inorder and postorder traversal of a tree, construct the binary tree.
inorder = [9,3,15,20,7]
postorder = [9,15,7,20,3] 

output: 
    3
   / \
  9  20
    /  \
   15   7  */

class TreeNode{
 
  TreeNode left;
  TreeNode right;
  
  int val;
  TreeNode(int val){
    this.val=val;
    this.left=null;
    this.right=null;
  
}

}

class Solution {
  
  
 public TreeNode makeTree(TreeNode root,int rootValue, int left, int right){
   
   if (root==null){
     System.out.println("in first");
    root= new TreeNode(rootValue);
    root.left=new TreeNode(left);
    root.right= new TreeNode(right);
    return root;
   }
   
   Queue<TreeNode> q= new LinkedList<>();
   q.add(root);
   while(!q.isEmpty()){
      TreeNode t= q.poll();
     if (t.val==rootValue){
       t.left=new TreeNode(left);
       t.right= new TreeNode(right);
        return root;
    }else{
      if (t.left!=null){
      q.add(t.left);
      
      }
       if (t.right!=null){
      q.add(t.right);
      }
     }
 }
      return root;  
 }
  
  public void inorder(TreeNode root, ArrayList<Integer> arr){
      if (root==null){
        return;
      }
    
      inorder(root.left, arr);
      arr.add(root.val);
      inorder(root.right, arr);
      
  }
  
  
  public static void main(String[] args) {

    int[] inorder = {9,3,15,20,7};
    int[] postorder = {9,15,7,20,3};
    
    HashMap<Integer, Integer> inorderIndex= new HashMap<>();
    HashMap<Integer, Integer> postorderIndex= new HashMap<>();
    
    for(int i=0; i<inorder.length;i++){
        inorderIndex.put(inorder[i], i);
        postorderIndex.put(postorder[i], i);
    }
    
    TreeNode root=null;
    Solution s= new Solution();
    
    Queue<Integer> q= new LinkedList<>();
    q.add(postorder[postorder.length-1]);
    while(!q.isEmpty()){
      int rootvalue=q.poll();
      //int indexofRootValue= postorderIndex.get(rootvalue);
      int indexofLeftChild= inorderIndex.get(rootvalue)-1;
      int indexofRightChild=postorderIndex.get(rootvalue)-1;
      if (indexofLeftChild>=0 && indexofRightChild>=0){  
      q.add(inorder[indexofLeftChild]);
      q.add(postorder[indexofRightChild]);
        root=s.makeTree(root,rootvalue, inorder[indexofLeftChild],postorder[indexofRightChild]);          
      }
    }
    
    System.out.println(root.val);
    
    ArrayList<Integer> arr= new ArrayList<>();
    s.inorder(root,arr);
    for(int i:arr){
    System.out.print(" "+i);
    
    }
    
    
    
  
    }
  }





// const login=()=>{
 
//   render()
  
// }

// export.modules=login



Rakuten

https://github.com/6chinwei/rakuten-interview-test/blob/master/rakuten-interview-test.js

https://www.glassdoor.com/Interview/The-Codility-Test-was-about-taking-an-integer-and-determine-how-many-different-arrangements-of-the-number-are-possible-So-QTN_1757034.htm
The Codility Test was about taking an integer and determine  how many different arrangements of the number are possible. So if given, 132, arrangements are 132, 123, 231, 213, 312, 321. So the function should return 6.


